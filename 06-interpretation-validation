=================================================
Chapter 6: From Interpretation to Validation
=================================================

State
-----

A state represents the values of program variables.

Formally, a state is a function s: Var -> Val
  where Var is the set of variables
  and Val is the set of values

Notation:
  s(x)        - value of variable x in state s
  s[x := v]   - state identical to s except x maps to v

Definition of state update:
  s[x := v](y) = v      if y = x
  s[x := v](y) = s(y)   if y != x


Denotational Semantics
----------------------

Denotational semantics interprets programs as mathematical functions.

Each construct maps to a mathematical object:
  Expressions denote values
  Statements denote state transformations (functions State -> State)

For expressions:
  [[n]](s) = n
  [[x]](s) = s(x)
  [[e1 + e2]](s) = [[e1]](s) + [[e2]](s)
  [[e1 * e2]](s) = [[e1]](s) * [[e2]](s)

For statements:
  [[x := e]](s) = s[x := [[e]](s)]
    (state where x maps to value of e)
  
  [[c1; c2]](s) = [[c2]]([[c1]](s))
    (compose state transformations)

This provides a compositional, mathematical meaning for programs.


Rewrite Systems
---------------

A rewrite system is a pair (T, R) where:
  T - set of terms
  R - set of rewrite rules (pairs of terms)

A rewrite rule (L, R) is written L -> R.
A term t rewrites to t' (written t => t') if t contains L and t' replaces it with R.

Desirable properties:
  Confluence: if t => t1 and t => t2, then EXISTS t3 such that t1 =>* t3 and t2 =>* t3
  Termination: no infinite rewrite sequences exist
  Normal form: a term that cannot be rewritten further


Lambda Calculus
---------------

Lambda calculus is a formal system for expressing computation via functions.

Syntax:
  M ::= x | LAMBDA x. M | M1 M2

Beta-reduction:
  (LAMBDA x. M) N ==> M[x := N]
  where M[x := N] substitutes N for free occurrences of x in M.


Operational Semantics: Small-Step
----------------------------------

Small-step semantics defines single computation steps.

Transition relation:
  <e, s> -> <e', s'>
  Expression e in state s reduces to e' in state s'

Example rules for expressions:
  <x, s> -> <s(x), s>
  
  <e1, s> -> <e1', s'>
  -------------------------
  <e1 + e2, s> -> <e1' + e2, s'>

Example rules for statements:
  <x := e, s> -> <x := e', s'>  if <e, s> -> <e', s'>
  <x := v, s> -> <skip, s[x := v]>
  
  <c1, s> -> <c1', s'>
  -------------------------
  <c1; c2, s> -> <c1'; c2, s'>
  
  <skip; c2, s> -> <c2, s>


Operational Semantics: Big-Step
--------------------------------

Big-step semantics defines complete evaluation.

Evaluation relation:
  <e, s> => v
  Expression e in state s evaluates to value v

Example rules for expressions:
  <n, s> => n
  
  <e1, s> => n1    <e2, s> => n2
  -----------------------------------
  <e1 + e2, s> => n1 + n2

Example rules for statements:
  <c, s> => s'
  Statement c in state s produces state s'
  
  <x := e, s> => s[x := [[e]](s)]
  
  <c1, s> => s'    <c2, s'> => s''
  ---------------------------------
  <c1; c2, s> => s''


Hoare Logic
-----------

Hoare logic provides formal reasoning about program correctness.

Judgment:
  {P} c {Q}
  where P, Q are assertions (predicates on states), c is a command

Inference rules:

  Assignment:
  ------------------------
  {P[x := e]} x := e {P}

  Sequence:
  {P} c1 {Q}    {Q} c2 {R}
  --------------------------
  {P} c1; c2 {R}

  Conditional:
  {P AND b} c1 {Q}    {P AND NOT b} c2 {Q}
  ------------------------------------------
  {P} if b then c1 else c2 {Q}

  While (loop invariant I):
  {I AND b} c {I}
  ----------------------------------
  {I} while b do c {I AND NOT b}

  Consequence:
  P' IMPLIES P    {P} c {Q}    Q IMPLIES Q'
  --------------------------------------------
  {P'} c {Q'}

Example:
  {x = 5} y := x + 1 {y = 6}
  {x > 0} while x > 0 do x := x - 1 {x = 0}


Temporal Logic
--------------

Temporal logic formalizes reasoning about execution sequences.

Key operators over infinite state sequence:
  NEXT phi           - phi holds in next state
  EVENTUALLY phi     - phi holds in some future state
  ALWAYS phi         - phi holds in all future states
  phi1 UNTIL phi2    - phi1 holds until phi2 holds

Example:
  ALWAYS (request IMPLIES EVENTUALLY response)




