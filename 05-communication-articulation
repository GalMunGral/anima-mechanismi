=================================================
Chapter 5: From Communication to Articulation
=================================================

Alphabets
---------

An alphabet is a finite set of symbols.

Notation:
  A = {0, 1}           - binary alphabet
  A = {a, b, c, ..., z} - lowercase letters

Alphabets provide the basic symbols for constructing strings.


Strings
-------

A string over alphabet A is a finite sequence (indexed collection) over A.

Notation:
  Empty string: EPSILON (length 0)
  Length of string s: |s|
  Concatenation: s1 s2 (join strings together)

Examples over alphabet {0, 1}:
  EPSILON, 0, 1, 01, 101, 0011


Kleene Star
-----------

The Kleene star A* is the set of all strings over alphabet A.

Formal definition:
  A* = A(0) UNION A(1) UNION A(2) UNION A(3) UNION ...
  where A(n) = {strings of length n over A}
  
  A(0) = {EPSILON}
  A(1) = A
  A(2) = {ab | a, b IN A}
  A(n) = {s1 s2 | s1 IN A(n-1), s2 IN A}

Examples:
  {0, 1}* = {EPSILON, 0, 1, 00, 01, 10, 11, 000, ...}
  {a}* = {EPSILON, a, aa, aaa, aaaa, ...}

A+ denotes all non-empty strings (A* - {EPSILON}).


Regular Languages
-----------------

A regular language over alphabet A can be built from basic languages using
regular operations.

Basic languages:
  EMPTY SET     - {}
  {EPSILON}     - contains only the empty string
  {a}           - single symbol, for each a IN A

Regular operations:
  Union: L1 UNION L2
  Concatenation: L1 L2 = {s1 s2 | s1 IN L1, s2 IN L2}
  Kleene star: L* = L(0) UNION L(1) UNION L(2) UNION ...
               where L(n) = {strings formed by concatenating n strings from L}

Closure properties:
  Regular languages are closed under union, intersection, complement,
  concatenation, and Kleene star.

Regular expressions provide notation for describing regular languages.


Context-Free Grammars
---------------------

A context-free grammar generates strings through production rules.

Definition:
  G = (V, T, P, S) where:
    V - set of variables (non-terminals)
    T - set of terminals (alphabet)
    P - set of production rules
    S - start variable

Production rules in BNF notation:
  <variable> ::= <expression>

Example - balanced parentheses:
  S ::= EPSILON
  S ::= (S)
  S ::= SS

Generates: EPSILON, (), (()), ()(), (())(), ...

Example - arithmetic expressions:
  <expr> ::= <number>
  <expr> ::= <expr> + <expr>
  <expr> ::= <expr> * <expr>
  <expr> ::= (<expr>)

Example - statements:
  <stmt> ::= <var> := <expr>
  <stmt> ::= <stmt> ; <stmt>
  <stmt> ::= if <expr> then <stmt> else <stmt>
  <stmt> ::= while <expr> do <stmt>

These grammars define the syntax of programs.




